#include <stdio.h>
#include <comedilib.h>
#include <fcntl.h>
#include <stdlib.h>
#include <unistd.h>
#include <errno.h>
#include <getopt.h>
#include <ctype.h>
#include <math.h>
#include <string.h>
#include <sys/mman.h>
#include <stdlib.h>
#include "/usr/local/src/comedilib/demo/examples.h"

#include <iostream>
#include <cstring>
#include <sys/socket.h>
#include <netdb.h>


static void write_waveform(sampl_t *buffer, int size, double amplitude, double offset, int maxdata)
{
        int i;

        for(i = 0; i < size; ++i)
        {
                double temp = (amplitude / 2.) * sin((2. * M_PI * i) / size) + offset;
                if(temp < 0.) temp = 0.;
                if(temp > maxdata) temp = maxdata;
                buffer[i] = (sampl_t)temp;
        }
}


int main(int argc, char *argv[]){

        comedi_cmd cmd;
        int err;
        comedi_t *dev;
        unsigned int chanlist[16];
        unsigned int maxdata;
        comedi_range *rng;
        int ret;
        int size;
        int num_samples;
        sampl_t *map;
        /* peak-to-peak amplitude, in DAC units (i.e., 0-4095) */
        double amplitude;
        /* offset, in DAC units */
        double offset;
	struct parsed_options options;

	init_parsed_options(&options);
        options.subdevice = -1;
	parse_options(&options, argc, argv);

        /* Force n_chan to be 1 */
        options.n_chan = 1;

        dev = comedi_open(options.filename);
        if(dev == NULL){
                fprintf(stderr, "error opening %s\n", options.filename);
                return -1;
        }
        if(options.subdevice < 0)
                options.subdevice = comedi_find_subdevice_by_type(dev,COMEDI_SUBD_AO, 0);

        maxdata = comedi_get_maxdata(dev, options.subdevice, 0);
        rng = comedi_get_range(dev, options.subdevice, 0, 0);


        offset = (double)comedi_from_phys(0.0, rng, maxdata);
        amplitude = (double)comedi_from_phys(1.0, rng, maxdata) - offset;

        memset(&cmd,0,sizeof(cmd));
        cmd.subdev = options.subdevice;
        cmd.flags = 0;
        cmd.start_src = TRIG_INT;
        cmd.start_arg = 0;
        cmd.scan_begin_src = TRIG_TIMER;
        cmd.scan_begin_arg = 1e9 / options.freq;
        cmd.convert_src = TRIG_NOW;
        cmd.convert_arg = 0;
        cmd.scan_end_src = TRIG_COUNT;
        cmd.scan_end_arg = options.n_chan;
        cmd.stop_src = TRIG_NONE;
        cmd.stop_arg = 0;

        cmd.chanlist = chanlist;
        cmd.chanlist_len = options.n_chan;

        chanlist[0] = CR_PACK(options.channel, options.range, options.aref);

        dump_cmd(stdout, &cmd);

        err = comedi_command_test(dev, &cmd);
        if (err < 0) {
                comedi_perror("comedi_command_test");
                exit(1);
        }

        err = comedi_command_test(dev, &cmd);
        if (err < 0) {
                comedi_perror("comedi_command_test");
                exit(1);
        }

        if ((err = comedi_command(dev, &cmd)) < 0) {
                comedi_perror("comedi_command");
                exit(1);
        }

        size = 100;
	write_waveform(map, num_samples, amplitude, offset, maxdata);
        fprintf(stderr, "buffer size is %d\n", size);
        map = mmap(NULL, size, PROT_WRITE, MAP_SHARED, comedi_fileno(dev), 0);
        if(map == MAP_FAILED)
        {
                perror("mmap");
                exit(1);
        }



	// set up socket and listen
	int status;
	struct addrinfo host_info;
	struct addrinfo *host_info_list;
	
	memset(&host_info, 0, sizeof host_info);

	std::cout << "Setting up the structs..." << std::endl;

	host_info.ai_family = AF_UNSPEC;
	host_info.ai_socktype = SOCK_STREAM;
	host_info.ai_flags = AI_PASSIVE;

	status = getaddrinfo(NULL, "5555", &host_info, &host_info_list);
	if (status != 0) std::cout << "getaddrinfo error" << gai_strerror(status);
	
	std::cout << "Creating a socket..." << std::endl;
	int socketfd;
	socketfd = socket(host_info_list->ai_family, host_info_list->ai_socktype, host_info_list->ai_protocol);
	if (socketfd == -1) std::cout << std::endl;

	std::cout << "Binding socket..." << std::endl;
	int yes = 1;
	status = setsockopt(socketfd, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(int));
	status = bind(socketfd, host_info_list->ai_addr,host_info_list->ai_addrlen);
	if (status == -1) std::cout << "bind error" << std::endl;

	std::cout << "Listening for connections..." << std::endl;
	status = listen(socketfd,1);
	if (status == -1) std::cout << "listen error" << std::endl;

	int new_sd;
	struct sockaddr_storage their_addr;
	socklen_t addr_size = sizeof(their_addr);
	new_sd = accept(socketfd, (struct sockaddr *)&their_addr, &addr_size);
	if (new_sd == -1){
		std::cout << "listen error" << std::endl;
	}
	else{
		std::cout << "Connection accepted. Using new socketfd: " << new_sd << std::endl;
	}

	int buffer_size = 100;
	int last;
	ssize_t bytes_recieved;
	const char* incomming_data_buffer[buffer_size];
	int separator;
	for(;;){
		bytes_recieved = recv(new_sd, incomming_data_buffer,1000, 0);
		
		if (incomming_data_buffer[0] == "q"){
			std::cout << "Eye-tracker closed" << std::endl;
			freeaddrinfo(host_info_list);
			shutdown(new_sd,2);
			shutdown(socketfd,2);
			return 0;
		}
		else{
		        // parse incomming data buffer
	                for (int i = 0; i < buffer_size; i = i+1){
        	                if (incomming_data_buffer[i]==",");
                	        separator = i;
                	}
                	const char* first[separator];
              		const char* last[100-separator];
			for (int i=0; i<separator; i = i+1){
				first[i]=incomming_data_buffer[i];
			}
			for (int i=0; i<100-separator; i=i+1){
				last[i] = incomming_data_buffer[i+separator+1];
			}
	                //std::copy(incomming_data_buffer + 0, incomming_data_buffer + separator, first);
	                //std::copy(incomming_data_buffer + (100-separator), incomming_data_buffer + 99, last);
			
			//std::string fir = first;
			//std::string las = last;
			
			float f = std::atof (first[0]);
			float l = std::atof (last[0]);
			
			write(comedi_fileno(dev),(void *)&(f),sizeof(float));
			std::cout << f << std::endl;
			//std::cout << incomming_data_buffer << std::endl;
		}
	}

}
